{"componentChunkName":"component---src-templates-post-template-tsx","path":"/study-blog/object-oriented/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>객체지향(Object-Oriented)</h1>\n<p>현실 세계의 개체를 하나의 객체로 만들어, 객체들을 조립해서 작성할 수 있는 기법</p>\n<ul>\n<li>장점\n<ul>\n<li>소프트웨어 재사용 및 확장 용이</li>\n<li>개발 속도↑</li>\n<li>유지보수 수월</li>\n<li>현실 세계 모형화 → 사용자/개발자 이해 수월</li>\n</ul>\n</li>\n</ul>\n<h2>구성 요소</h2>\n<h3>객체(Object)</h3>\n<p>데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 소프트웨어 모듈</p>\n<ul>\n<li>특성\n<ul>\n<li>독립적으로 식별 가능한 이름 존재</li>\n<li>일반적으로 상태는 시간에 따라 변함</li>\n<li>객체 간의 상호 연관성에 의한 관계 형성</li>\n<li>행위의 특징 나타낼 수 있음</li>\n<li>기억장소 존재</li>\n</ul>\n</li>\n</ul>\n<h3>클래스(Class)</h3>\n<p>공통된 속성과 연산을 갖는 객체의 집합</p>\n<blockquote>\n<p><strong>인스턴스(Instance)</strong> : 클래스에 속한 각각의 객체</p>\n<p><strong>인스턴스화(Instantiation)</strong> : 클래스로부터 새로운 객체를 생성하는 것</p>\n</blockquote>\n<h3>캡슐화(Encapsulation)</h3>\n<p>데이터와 데이터를 처리하는 함수를 하나로 묶는 것</p>\n<ul>\n<li>장점\n<ul>\n<li>외부 모듈 변경으로 인한 파급 효과↓</li>\n<li>재사용 용이</li>\n<li>인터페이스 단순</li>\n<li>객체 간 결합도↓</li>\n</ul>\n</li>\n</ul>\n<h3>상속(Inheritance)</h3>\n<p>이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것</p>\n<ul>\n<li>장점\n<ul>\n<li>속성/연산 재정의↓</li>\n<li>상속받은 것 외의 속성/연산 첨가 가능</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>다중 상속(Multiple Inheritance)</strong> : 두 개 이상의 상위 클래스로부터 상속</p>\n</blockquote>\n<h3>다형성(Polymorphism)</h3>\n<p>하나의 메시지에 대해 각 객체의 고유한 방법으로 응답할 수 있는 능력</p>\n<h3>연관성(Relationship)</h3>\n<p>두 이상의 객체들이 상호 참조하는 관계</p>\n<h2>설계 원칙</h2>\n<table>\n<thead>\n<tr>\n<th align=\"center\">SOLID</th>\n<th align=\"center\">설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">단일 책임 원칙(SRP, Single Responsibility Principle)</td>\n<td align=\"center\">객체는 단 하나의 책임만 가짐<br />응집도↑, 결합도↓</td>\n</tr>\n<tr>\n<td align=\"center\">개방-폐쇄 원칙(OCP, Open-Closed Principle)</td>\n<td align=\"center\">기존 코드 변경없이 기능 추가 가능하도록 설계<br />캡슐화</td>\n</tr>\n<tr>\n<td align=\"center\">리스코프 치환 원칙(LSP, Liskov Substitution Principle)</td>\n<td align=\"center\">자식 클래스는 최소한 부모 클래스에서 가능한 행위는 수행 가능해야 함<br />자식 클래스는 확장만 수행</td>\n</tr>\n<tr>\n<td align=\"center\">인터페이스 분리 원칙(ISP, Interface Segregation Principle)</td>\n<td align=\"center\">사용하지 않는 인터페이스와 의존 관계/영향 X<br />인터페이스가 갖는 하나의 책임</td>\n</tr>\n<tr>\n<td align=\"center\">의존 역전 원칙(DIP, Dependency Inversion Principle)</td>\n<td align=\"center\">추상성이 높은 클래스와 의존 관계 맺어야 함<br />인터페이스 활용 시 원칙 준수 가능</td>\n</tr>\n</tbody>\n</table>","frontmatter":{"page":"study-blog","categories":["Software-Design"],"date":"2023.03.04","title":"객체지향","subTitle":null}}}]}},"pageContext":{"slug":"/study-blog/object-oriented/"}},"staticQueryHashes":[],"slicesMap":{}}